<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Open Source | Dan Vatterott]]></title>
  <link href="https://danvatterott.com/blog/categories/open-source/atom.xml" rel="self"/>
  <link href="https://danvatterott.com/"/>
  <updated>2018-03-18T13:51:25-05:00</updated>
  <id>https://danvatterott.com/</id>
  <author>
    <name><![CDATA[Dan Vatterott]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Using Cron to Automate Jobs on Ubuntu]]></title>
    <link href="https://danvatterott.com/blog/2017/09/01/automating-jobs-on-ubuntu/"/>
    <updated>2017-09-01T17:04:17-05:00</updated>
    <id>https://danvatterott.com/blog/2017/09/01/automating-jobs-on-ubuntu</id>
    <content type="html"><![CDATA[<p>I recently spent an entire afternoon debugging a solution for automatically launching a weekly emr job.</p>

<p>Hopefully, I can save someone the same pain by writing this blog post.</p>

<p>I decided to use Cron to launch the weekly jobs. Actually launching a weekly job on Cron was not difficult. Check out the <a href="https://help.ubuntu.com/community/CronHowto">Ubuntu Cron manual</a> for a good description on how to use Cron.</p>

<p>What took me forever was realizing that <strong>Cron jobs have an extremely limited path</strong>. Because of this, specifying the complete path to executed files <strong>and their executors</strong> is necessary.</p>

<p>Below I describe how I used an ec2 instance (Ubuntu 16.04) to automatically launch this weekly job.</p>

<p>First, here is what my Cron job list looks like (call “crontab -e” in the terminal).</p>

<p>{% codeblock lang:bash %}
SHELL=/bin/bash
05 01 * * 2 $HOME/automated_jobs/production_cluster.sh
{% endcodeblock %}</p>

<p>The important thing to note here is that I am creating the variable SHELL, and $HOME is replaced by the actual path to my home directory.</p>

<p>Next, is the shell script called by Cron.</p>

<p>{% codeblock lang:bash %}
#!/bin/bash
source $HOME/.bash_profile</p>

<p>$HOME/automated_jobs/launch_production_cluster.py
{% endcodeblock %}</p>

<p>Again, $HOME is replaced with the actual path to my home directory.</p>

<p>I had to make this shell script and the python script called within it executable (call “chmod +x” in the terminal). The reason that I used this shell script rather than directly launching the python script from Cron is I wanted access to environment variables in my bash_profile. In order to get access to them, I had to source bash_profile.</p>

<p>Finally, below I have the python file that executes the week job that I wanted. I didn’t include the code that actually launches our emr cluster because that wasn’t the hard part here, but just contact me if you would like to see it.</p>

<p>{% codeblock lang:python %}
#!$HOME/anaconda2/bin/python
import os
import sys
import datetime as dt
from subprocess import check_output</p>

<h1 id="setup-logging">setup logging</h1>
<p>old_stdout = sys.stdout
log_file = open(“production_cluster_%s.log” % dt.datetime.today().strftime(‘%Y_%m_%d’), “w”)
sys.stdout = log_file</p>

<p>print ‘created log file’</p>

<h1 id="organize-local-files-and-s3-files">organize local files and s3 files</h1>

<p>print ‘organized files’</p>

<h1 id="call-emr-cluster">call emr cluster</h1>

<p>print ‘launched production job’</p>

<h1 id="close-log-file">close log file</h1>
<p>sys.stdout = old_stdout
log_file.close()
{% endcodeblock %}</p>

<p>While the code is not included here, I use aws cli to launch my emr cluster, and I had to specify the path to aws (call “which aws” in the terminal) when making this call.</p>

<p>You might have noticed the logging I am doing in this script. I found logging both within this python script and piping the output of this script to additional logs helpful when debugging.</p>

<p>The Ubuntu Cron manual I linked above, makes it perfectly clear that my Cron path issues are common, but I wanted to post my solution in case other people needed a little guidance.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Are We in a TV Golden Age?]]></title>
    <link href="https://danvatterott.com/blog/2017/07/15/are-we-in-a-tv-golden-age/"/>
    <updated>2017-07-15T15:12:26-05:00</updated>
    <id>https://danvatterott.com/blog/2017/07/15/are-we-in-a-tv-golden-age</id>
    <content type="html"><![CDATA[<p>I recently found myself in a argument with my wife regarding whether TV was better now than previously. I believed that TV was better now than 20 years ago. My wife contended that there was simply more TV content being produced, and that this led to more good shows, but shows are not inherently any better.</p>

<p>This struck me as a great opportunity to do some quick data science. For this post, I scraped the names (from wikipedia) and ratings (from <a href="https://www.themoviedb.org/">TMDb</a>) of all American TV shows. I did the same for major American movies, so that I could have a comparison group (maybe all content is better or worse). The ratings are given by TMDb’s users and are scores between 1 and 10 (where 10 is a great show/movie and 1 is a lousy show/movie).</p>

<p>All the code for this post can be found <a href="https://github.com/dvatterott/tv_vs_movies">on my github</a>.</p>

<p>I decided to operationalize my “golden age of TV” hypothesis as the average TV show is better now than previously. This would be expressed as a positive slope (beta coefficient) when building a linear regression that outputs the rating of a show given the date on which the show first aired. My wife predicted a slope near zero or negative (shows are no better or worse than previously).</p>

<p>Below, I plot the ratings of TV shows and movies across time. Each show is a dot in the scatter plot. Show rating (average rating given my TMBb) is on the y-axis. The date of the show’s first airing is on the x-axis. When I encountered shows with the same name, I just tacked a number onto the end. For instance, show “x” would become show “x_1.” The size of each point in the scatter plot is the show’s “popularity”, which is a bit of a black box, but it’s given by TMBb’s API. TMDb does not give a full description of how they calculate popularity, but they do say its a function of how many times an item is viewed on TMDb, how many times an item is rated, and how many times the item has been added to watch or favorite list. I decided to depict it here just to give the figures a little more detail. The larger the dot, the more popular the show.</p>

<p>Here’s a plot of all TV shows across time.</p>

<iframe src="{{ root_url }}/images/tv_movies/index_tv.html" marginwidth="0" marginheight="0" scrolling="no" width="800" height="500"></iframe>

<p>To test the “golden age of TV” hypothesis, I coded up a linear regression in javascript (below). I put the regression’s output as a comment at the end of the code.
Before stating whether the hypothesis was rejected or not, I should note that that I removed shows with less than 10 votes because these shows had erratic ratings.</p>

<p>As you can see, there is no evidence that TV is better now that previously. In fact, if anything, this dataset says that TV is worse (but more on this later).</p>

<p>{% codeblock lang:javascript %}
function linearRegression(y,x){</p>

<pre><code>var lr = {};
var n = y.length;
var sum_x = 0;
var sum_y = 0;
var sum_xy = 0;
var sum_xx = 0;
var sum_yy = 0;

for (var i = 0; i &lt; y.length; i++) {

    sum_x += x[i];
    sum_y += y[i];
    sum_xy += (x[i]*y[i]);
    sum_xx += (x[i]*x[i]);
    sum_yy += (y[i]*y[i]);
}

lr['slope'] = (n * sum_xy - sum_x * sum_y) / (n*sum_xx - sum_x * sum_x);
lr['intercept'] = (sum_y - lr.slope * sum_x)/n;
lr['r2'] = Math.pow((n*sum_xy - sum_x*sum_y)/Math.sqrt((n*sum_xx-sum_x*sum_x)*(n*sum_yy-sum_y*sum_y)),2);

return lr;
</code></pre>

<p>};</p>

<p>var yval = data
    .filter(function(d) { return d.vote_count &gt; 10 })
    .map(function (d) { return parseFloat(d.vote_average); });
var xval = data
    .filter(function(d) { return d.vote_count &gt; 10 })
    .map(function (d) { return d.first_air_date.getTime() / 1000; });
var lr = linearRegression(yval,xval);
// Object { slope: -3.754543948800799e-10, intercept: 7.0808230581192815, r2: 0.038528573017115 }</p>

<p>{% endcodeblock %}</p>

<p>I wanted to include movies as a comparison to TV. Here’s a plot of all movies across time.</p>

<iframe src="{{ root_url }}/images/tv_movies/index_movie.html" marginwidth="0" marginheight="0" scrolling="no" width="800" height="500"></iframe>

<p>It’s important to note that I removed all movies with less than 1000 votes. This is completely 100% unfair, BUT I am very proud of my figures here and things get a little laggy when including too many movies in the plot. Nonetheless, movies seem to be getting worse over time! More dramatically than TV shows!</p>

<p>{% codeblock lang:javascript %}
var yval = data
    .filter(function(d) { return d.vote_count &gt; 1000 })
    .map(function (d) { return parseFloat(d.vote_average); });
var xval = data
    .filter(function(d) { return d.vote_count &gt; 1000 })
    .map(function (d) { return d.first_air_date.getTime() / 1000; });
var lr = linearRegression(yval,xval);
// Object { slope: -8.11645196776367e-10, intercept: 7.659366705415847, r2: 0.16185069580043676 }
{% endcodeblock %}</p>

<p>Okay, so this was a fun little analysis, but I have to come out and say that I wasn’t too happy with my dataset and the conclusions we can draw from this analysis are only as good as the dataset.</p>

<p>The first limitation is that recent content is much more likely to receive a rating than older content, which could systematically bias the ratings of older content (e.g., only good shows from before 2000 receive ratings). It’s easy to imagine how this would lead us to believing that all older content is better than it actually was.</p>

<p>Also, TMDb seems to have IMDB type tastes by which I mean its dominated by young males. For instance, while I don’t like the show “Keeping up the Kardashians,” it’s definitely not the worst show ever. Also, “Girls” is an amazing show which gets no respect here. The quality of a show is in the eye of the beholder, which in this case seems to be boys.</p>

<p>I would have used Rotten Tomatoes’ API, but they don’t provide access to TV ratings.</p>

<p>Even with all these caveats in mind, it’s hard to defend my “golden age of TV” hypothesis. Instead, it seems like there is just more content being produced, which leads to more good shows (yay!), but the average show is no better or worse than previously.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[My First Kodi Addon - PBS NewsHour (a Tutorial)]]></title>
    <link href="https://danvatterott.com/blog/2017/03/11/my-first-kodi-addon-pbs-newshour/"/>
    <updated>2017-03-11T12:21:03-06:00</updated>
    <id>https://danvatterott.com/blog/2017/03/11/my-first-kodi-addon-pbs-newshour</id>
    <content type="html"><![CDATA[<p>NOTE: Since writing this post, PBS Newshour changed their site. They know use the url, https://www.pbs.org/newshour/video. The mechanics here will work but the url has changed and some of the queries need to be changed too. Check the repo for a working version of the code.</p>

<p>I’ve been using <a href="https://kodi.tv/">Kodi/XBMC</a> since 2010. It provides a flexible and (relatively) intuitive interface for interacting with content through your TV (much like an apple TV). One of the best parts of Kodi is the addons - these are apps that you can build or download. For instance, I use the NBA League Pass addon for watching Wolves games. I’ve been looking for a reason to build my own Kodi addon for years.</p>

<p>Enter <a href="http://www.pbs.org/newshour/">PBS NewsHour</a>. If you’re not watching PBS NewsHour, I’m not sure what you’re doing with your life because it’s the shit. It rocks. PBS NewsHour disseminates all their content on youtube and their website. For the past couple years, I’ve been watching their broadcasts every morning through the <a href="http://kodi.wiki/view/Add-on:YouTube">Youtube addon</a>. This works fine, but it’s clunky. I decided to stream line watching the NewsHour by building a Kodi addon for it.</p>

<p>I used <a href="http://forum.kodi.tv/showthread.php?tid=254207">this tutorial</a> to build a Kodi addon that accesses the PBS NewsHour content through the youtube addon. This addon can be found on <a href="https://github.com/dvatterott/Kodi_addons/tree/master/plugin.video.pbsnewshouryoutube">my github</a>. The addon works pretty well, but it includes links to all NewsHour’s content, and I only want the full episodes. I am guessing I could have modified this addon to get what I wanted, but I really wanted to build my own addon from scratch.</p>

<p>The addon I built is available on <a href="https://github.com/dvatterott/Kodi_addons/tree/master/plugin.video.pbsnewshour">my github</a>. To build my addon, I used <a href="http://kodi.wiki/view/HOW-TO:Video_addon">this tutorial</a>, and some code from <a href="https://github.com/learningit/Kodi-plugins-source">this github</a> repository. Below I describe how the addon works. I only describe the file default.py because this file does the majority of the work, and I found the linked tutorials did a good job explaining the other files.</p>

<p>I start by importing libraries that I will use. Most these libraries are used for scraping content off the web. I then create some basic variables to describe the addon’s name (addonID), its name in kodi (base_url), the number used to refer to it (addon_handle - I am not sure how this number is used), and current arguments sent to my addon (args).</p>

<p>{% codeblock lang:python %}
import zlib
import json
import sys
import urlparse
import xbmc
import xbmcgui
import xbmcplugin</p>

<p>import urllib2
import re</p>

<p>addonID = ‘plugin.video.pbsnewshour’</p>

<p>base_url = sys.argv[0]
addon_handle = int(sys.argv[1])
args = urlparse.parse_qs(sys.argv[2][1:])
{% endcodeblock %}</p>

<p>The next function, getRequest, gathers html from a website (specified by the variable url). The dictionary httpHeaders tells the website a little about myself, and how I want the html. I use urllib2 to get a compressed version of the html, which is decompressed using zlib.</p>

<p>{% codeblock lang:python %}
# ———–  Create some functions for fetching videos —————
# https://github.com/learningit/Kodi-plugins-source/blob/master/script.module.t1mlib/lib/t1mlib.py
UTF8 = ‘utf-8’
USERAGENT = “"”Mozilla/5.0 (Windows NT 6.3; WOW64) AppleWebKit/537.36 \
            (KHTML, like Gecko) Chrome/41.0.2272.101 Safari/537.36”””
httpHeaders = {‘User-Agent’: USERAGENT,
               ‘Accept’: “application/json, text/javascript, text/html,<em>/</em>”,
               ‘Accept-Encoding’: ‘gzip,deflate,sdch’,
               ‘Accept-Language’: ‘en-US,en;q=0.8’
               }</p>

<p>def getRequest(url, udata=None, headers=httpHeaders):
    req = urllib2.Request(url.encode(UTF8), udata, headers)
    try:
        response = urllib2.urlopen(req)
        page = response.read()
        if response.info().getheader(‘Content-Encoding’) == ‘gzip’:
            page = zlib.decompress(page, zlib.MAX_WBITS + 16)
        response.close()
    except Exception:
        page = “”
        xbmc.log(msg=’REQUEST ERROR’, level=xbmc.LOGDEBUG)
    return(page)
{% endcodeblock %}</p>

<p>The hardest part of building this addon was finding video links. I was able to find a <a href="https://github.com/learningit/Kodi-plugins-source/">github repo</a> with code for identifying links to PBS’s videos, but PBS initially posts their videos on youtube. I watch PBS NewsHour the morning after it airs, so I needed a way to watch these youtube links. I started this post by saying I wanted to avoid using Kodi’s youtube addon, but I punted and decided to use the youtube addon to play these links. Below is a function for finding the youtube id of a video.</p>

<p>{% codeblock lang:python %}
def deal_with_youtube(html):
    vid_num = re.compile(‘<span class="youtubeid">(.+?)</span>’,
                         re.DOTALL).search(html)
    url = vid_num.group(1)
    return url
{% endcodeblock %}</p>

<p>This next function actually fetches the videos (the hard part of building this addon). This function fetches the html of the website that has PBS’s video. It then searches the html for “coveplayerid,” which is PBS’s name for the video. I use this name to create a url that will play the video. I get the html associated with this new url, and search it for a json file that contains the video. I grab this json file, and viola I have the video’s url! In the final part of the code, I request a higher version of the video than PBS would give me by default.</p>

<p>If I fail to find “coveplayerid,” then I know this is a video with a youtube link, so I grab the youtube id. Some pages have a coveplayerid class, but no actual coveplayerid. I also detect these cases and find the youtube id when it occurs.</p>

<p>{% codeblock lang:python %}
# https://github.com/learningit/Kodi-plugins-source/blob/master/plugin.video.thinktv/resources/lib/scraper.py
# modified from link above
def getAddonVideo(url, udata=None, headers=httpHeaders):
    html = getRequest(url)</p>

<pre><code>vid_num = re.compile('&lt;span class="coveplayerid"&gt;(.+?)&lt;/span&gt;',
                     re.DOTALL).search(html)
if vid_num:
    vid_num = vid_num.group(1)
    if 'youtube' in vid_num:
        return deal_with_youtube(html)
    pg = getRequest('http://player.pbs.org/viralplayer/%s/' % (vid_num))
    query = """PBS.videoData =.+?recommended_encoding.+?'url'.+?'(.+?)'"""
    urls = re.compile(query, re.DOTALL).search(pg)

    url = urls.groups()
    pg = getRequest('%s?format=json' % url)
    url = json.loads(pg)['url']
else:  # weekend links are initially posted as youtube vids
    deal_with_youtube(html)

url = url.replace('800k', '2500k')
if 'hd-1080p' in url:
    url = url.split('-hls-', 1)[0]
    url = url+'-hls-6500k.m3u8'
return url {% endcodeblock %}
</code></pre>

<p>This next function identifies full episodes that have aired in the past week. It’s the meat of the addon. The function gets the html of <a href="http://www.pbs.org/newshour/videos/">PBS NewsHour’s page</a>, and finds all links in a side-bar where PBS lists their past week’s episodes. I loop through the links and create a menu item for each one. These menu items are python objects that Kodi can display to users. The items include a label/title (the name of the episode), an image, and a url that Kodi can use to find the video url.</p>

<p>The most important part of this listing is the url I create. This url gives Kodi all the information I just described, associates the link with an addon, and tells Kodi that the link is playable. In the final part of the function, I pass the list of links to Kodi.</p>

<p>{% codeblock lang:python %}
# ————– Create list of videos ——————–
# http://kodi.wiki/view/HOW-TO:Video_addon
def list_videos(url=’http://www.pbs.org/newshour/videos/’):
    html = getRequest(url)</p>

<pre><code>query = """&lt;div class='sw-pic maxwidth'&gt;.+?href='(.+?)'.+?src="(.+?)".+?title="(.+?)" """
videos = re.compile(query, re.DOTALL).findall(html)

listing = []
for vids in videos:
    list_item = xbmcgui.ListItem(label=vids[2],
                                 thumbnailImage=vids[1])
    list_item.setInfo('video', {'title': vids[2]})
    list_item.setProperty('IsPlayable', 'true')

    url = ("%s?action=%s&amp;title=%s&amp;url=%s&amp;thumbnail=%s"
           % (base_url, 'play', vids[2], vids[0], vids[1]))

    listing.append((url, list_item, False))

# Add list to Kodi.
xbmcplugin.addDirectoryItems(addon_handle, listing, len(listing))
xbmcplugin.endOfDirectory(handle=addon_handle, succeeded=True) {% endcodeblock %}
</code></pre>

<p>Okay, thats the hard part. The rest of the code implements the functions I just described. The function below is executed when a user chooses to play a video. It gets the url of the video, and gives this to the xbmc function that will play the video. The only hiccup here is I check whether the link is for the standard PBS video type or not. If it is, then I give the link directly to Kodi. If it’s not, then this is a youtube link and I launch the youtube plugin with my youtube video id.</p>

<p>{% codeblock lang:python %}
def play_video(path):
    path = getAddonVideo(path)
    if ‘00k’ in path:
        play_item = xbmcgui.ListItem(path=path)
        xbmcplugin.setResolvedUrl(addon_handle, True, listitem=play_item)
    else:  # deal with youtube links
        path = ‘plugin://plugin.video.youtube/?action=play_video&amp;videoid=’ + path
        play_item = xbmcgui.ListItem(path=path)
        xbmcplugin.setResolvedUrl(addon_handle, True, listitem=play_item)
{% endcodeblock %}</p>

<p>This final function is launched whenever a user calls the addon or executes an action in the addon (thats why I call the function in the final line of code here). params is an empty dictionary if the addon is being opened. params being empty causes the addon to call list_videos, creating the list of episodes that PBS has aired in the past week. If the user selects one of the episodes, then router is called again, but this time the argument is the url of the selected item. This url is passed to the play_video function, which plays the video for the user!</p>

<p>{% codeblock lang:python %}
def router():
    params = dict(args)</p>

<pre><code>if params:
    if params['action'][0] == 'play':
        play_video(params['url'][0])
    else:
        raise ValueError('Invalid paramstring: {0}!'.format(params))
else:
    list_videos()
</code></pre>

<p>router()
{% endcodeblock %}</p>

<p>That’s my addon! I hope this tutorial helps people create future Kodi addons. Definitely reach out if you have questions. Also, make sure to check out the NewsHour soon and often. It’s the bomb.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Sifting the Overflow]]></title>
    <link href="https://danvatterott.com/blog/2017/03/04/sifting-the-overflow/"/>
    <updated>2017-03-04T09:11:45-06:00</updated>
    <id>https://danvatterott.com/blog/2017/03/04/sifting-the-overflow</id>
    <content type="html"><![CDATA[<p>In January 2017, I started a fellowship at <a href="http://insightdatascience.com/">Insight Data Science</a>. Insight is a 7 week program for helping academics transition from academia to careers in data science. In the first 4 weeks, fellows build data science products, and fellows present these products to different companies in the last 3 weeks.</p>

<p>At Insight, I built <a href="http://siftingtheoverflow.com/">Sifting the Overflow</a>, a chrome extension which you can install from the <a href="https://chrome.google.com/webstore/detail/sifting-the-overflow/japbeffaagcpbjilckaoigpocdgncind?hl=en-US&amp;gl=US">google chrome store</a>. Sifting the Overflow identifies the most helpful parts of answers to questions about the programming language Python on <a href="http://stackoverflow.com/">StackOverflow.com</a>. To created Sifting the Overflow, I trained a recurrent neural net (RNN) to identify “helpful” answers, and when you use the browser extension on a stackoverflow page, this RNN rates the helpfulness of each sentence of each answer. The sentences that my model believes to be helpful are highlighted so that users can quickly find the most helpful parts of these pages.</p>

<p>I wrote a quick post <a href="http://siftingtheoverflow.com/">here</a> about how I built Sifting the Overflow, so check it out if you’re interested. The code is also available on my <a href="https://github.com/dvatterott/stackex_sum">github</a>.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Simulating the Monty Hall Problem]]></title>
    <link href="https://danvatterott.com/blog/2016/12/25/simulating-the-monty-hall-problem/"/>
    <updated>2016-12-25T10:19:53-06:00</updated>
    <id>https://danvatterott.com/blog/2016/12/25/simulating-the-monty-hall-problem</id>
    <content type="html"><![CDATA[<p>I’ve been hearing about the <a href="https://en.wikipedia.org/wiki/Monty_Hall_problem">Monty Hall problem</a> for years and its never quite made sense to me, so I decided to program up a quick simulation.</p>

<p>In the Monty Hall problem, there is a car behind one of three doors. There are goats behind the other two doors. The contestant picks one of the three doors. Monty Hall (the game show host) then reveals that one of the two unchosen doors has a goat behind it. The question is whether the constestant should change the door they picked or keep their choice.</p>

<p>My first intuition was that it doesn’t matter whether the contestant changes their choice because its equally probable that the car is behind either of the two unopened doors, but I’ve been told this is incorrect! Instead, the contestant is more likely to win the car if they change their choice.</p>

<p>How can this be? Well, I decided to create a simple simulation of the Monty Hall problem in order to prove to myself that there really is an advantage to changing the chosen door and (hopefully) gain an intuition into how this works.</p>

<p>Below I’ve written my little simulation. A jupyter notebook with this code is available on my <a href="https://github.com/dvatterott/jupyter_notebooks">github</a>.</p>

<p>{% codeblock lang:python %}
import random
import copy
import numpy as np</p>

<p>start_vect = [1,0,0] #doors</p>

<p>samples = 5000 #number of simulations to run</p>

<p>change, no_change = [],[]
for i in range(samples):</p>

<pre><code>#shuffle data
vect = copy.copy(start_vect)
random.shuffle(vect)

#make choice
choice = vect.pop(random.randint(0,2))
no_change.append(choice) #outcome if do not change choice

#show bad door
try:
    bad = vect.pop(int(np.where(np.array(vect)==0)[0]))
except:
    bad = vect.pop(0)

change.append(vect) #outcome if change choice {% endcodeblock %}
</code></pre>

<p>Here I plot the results</p>

<p>{% codeblock lang:python %}
import matplotlib.pyplot as plt
%matplotlib inline
plt.style.use(‘ggplot’)</p>

<p>plt.bar([0.5,1.5],[np.mean(change),np.mean(no_change)],width=1.0)
plt.xlim((0,3))
plt.ylim((0,1))
plt.ylabel(‘Proportion Correct Choice’)
plt.xticks((1.0,2.0),[‘Change Choice’, ‘Do not change choice’])</p>

<p>import scipy.stats as stats
obs = np.array([[np.sum(change), np.sum(no_change)], [samples, samples]])
print(‘Probability of choosing correctly if change choice: %0.2f’ % np.mean(change))
print(‘Probability of choosing correctly if do not change choice: %0.2f’ % np.mean(no_change))
print(‘Probability of difference arising from chance: %0.5f’ % stats.chi2_contingency(obs)[1])
{% endcodeblock %}</p>

<pre><code>Probability of choosing correctly if change choice: 0.67
Probability of choosing correctly if do not change choice: 0.33
Probability of difference arising from chance: 0.00000
</code></pre>

<p><img src="{{ root_url }}/images/montyhall/montyhall1.png" /></p>

<p>Clearly, the contestant should change their choice!</p>

<p>So now, just to make sure I am not crazy, I decided to simulate the Monty Hall problem with the contestant choosing what door to open after Monty Hall opens a door with a goat.</p>

<p>{% codeblock lang:python %}
change, no_change = [],[]
for i in range(samples):
    #shuffle data
    vect = copy.copy(start_vect)
    random.shuffle(vect)</p>

<pre><code>#show bad door
bad = vect.pop(int(np.where(np.array(vect)==0)[0][0]))

#make choice
choice = vect.pop(random.randint(0,1))
no_change.append(choice)

change.append(vect)
</code></pre>

<p>{% endcodeblock %}</p>

<p>{% codeblock lang:python %}
plt.bar([0.5,1.5],[np.mean(change),np.mean(no_change)],width=1.0)
plt.xlim((0,3))
plt.ylim((0,1))
plt.ylabel(‘Proportion Correct Choice’)
plt.xticks((1.0,2.0),[‘Change Choice’, ‘Do not change choice’])</p>

<p>obs = np.array([[np.sum(change), np.sum(no_change)], [samples, samples]])
print(‘Probability of choosing correctly if change choice: %0.2f’ % np.mean(change))
print(‘Probability of choosing correctly if do not change choice: %0.2f’ % np.mean(no_change))
print(‘Probability of difference arising from chance: %0.5f’ % stats.chi2_contingency(obs)[1])
{% endcodeblock %}</p>

<pre><code>Probability of choosing correctly if change choice: 0.51
Probability of choosing correctly if do not change choice: 0.49
Probability of difference arising from chance: 0.57546
</code></pre>

<p><img src="{{ root_url }}/images/montyhall/montyhall2.png" /></p>

<p>Now, there is clearly no difference between whether the contestant changes their choice or not.</p>

<p>So what is different about these two scenarios?</p>

<p>In the first scenario, the contestant makes a choice before Monty Hall reveals which of the two unchosen options is incorrect. Here’s the intution I’ve gained by doing this - because Monty Hall cannot reveal what is behind the chosen door, when Monty Hall reveals what is behind one of the unchosen doors, this has no impact on how likely the car is to appear behind the chosen door. Yet, the probability that the car is behind the revealed door drops to 0 (because Monty Hall shows there’s a goat behind it), and the total probability must be conserved so the second unchosen door receives any belief that the car was behind the revealed door! Thus, the unchosen and unrevealed door becomes 66% likely to contain the car! I am still not 100% convinced of this new intuition, but it seems correct given these simulations!</p>
]]></content>
  </entry>
  
</feed>
