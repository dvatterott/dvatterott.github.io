<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Backpropogation | Dan Vatterott]]></title>
  <link href="https://danvatterott.com/blog/categories/backpropogation/atom.xml" rel="self"/>
  <link href="https://danvatterott.com/"/>
  <updated>2022-02-25T14:33:11-06:00</updated>
  <id>https://danvatterott.com/</id>
  <author>
    <name><![CDATA[Dan Vatterott]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[An Introduction to Neural Networks: Part 2]]></title>
    <link href="https://danvatterott.com/blog/2016/05/02/an-introduction-to-neural-networks-part-2/"/>
    <updated>2016-05-02T20:56:27-05:00</updated>
    <id>https://danvatterott.com/blog/2016/05/02/an-introduction-to-neural-networks-part-2</id>
    <content type="html"><![CDATA[<p>In a previous <a href="http://www.danvatterott.com/blog/2016/04/29/an-introduction-to-neural-networks-part-1/">post</a>, I described how to do <a href="https://en.wikipedia.org/wiki/Backpropagation">backpropogation</a> with a 1-layer <a href="https://en.wikipedia.org/wiki/Artificial_neural_network">neural network</a>. I’ve written this post assuming some familiarity with the previous post.</p>

<p>When first created, 1-layer neural networks <a href="https://en.wikipedia.org/wiki/Perceptron">brought about quite a bit of excitement</a>, but this excitement quickly dissipated when researchers realized that 1-layer <a href="https://en.wikipedia.org/wiki/Perceptrons_%28book%29">neural networks could only solve a limited set of problems</a>.</p>

<p>Researchers knew that adding an extra layer to the neural networks enabled neural networks to solve much more complex problems, but they didn’t know how to train these more complex networks.</p>

<p>In the previous post, I described “backpropogation,” but this wasn’t the portion of backpropogation that really changed the history of neural networks. What really changed neural networks is backpropogation with an extra layer. This extra layer enabled researchers to train more complex networks. The extra layer(s) is(are) called the <em>hidden layer(s)</em>. In this post, I will describe backpropogation with a hidden layer.</p>

<p>To describe backpropogation with a hidden layer, I will demonstrate how neural networks can solve the <a href="https://en.wikipedia.org/wiki/Exclusive_or">XOR problem</a>.</p>

<p>In this example of the XOR problem there are four items. Each item is defined by two values. If these two values are the same, then the item belongs to one group (blue here). If the two values are different, then the item belongs to another group (red here).</p>

<p>Below, I have depicted the XOR problem. The goal is to find a model that can distinguish between the blue and red groups based on an item’s values.</p>

<p>This code is also available as a jupyter notebook on <a href="https://github.com/dvatterott/jupyter_notebooks">my github</a>.</p>

<p>{% codeblock lang:python %}
import numpy as np #import important libraries.
from matplotlib import pyplot as plt
import pandas as pd
%matplotlib inline</p>

<p>plt.plot([0,1],[0,1],’bo’)
plt.plot([0,1],[1,0],’ro’)
plt.ylabel(‘Value 2’)
plt.xlabel(‘Value 1’)
plt.axis([-0.5,1.5,-0.5,1.5]);
{% endcodeblock %}</p>

<p><img src="{{ root_url }}/images/neural_net/exampleXOR.png" /></p>

<p>Again, each item has two values. An item’s first value is represented on the x-axis. An items second value is represented on the y-axis. The red items belong to one category and the blue items belong to another.</p>

<p>This is a non-linear problem because no linear function can segregate the groups. For instance, a horizontal line could segregate the upper and lower items and a vertical line could segregate the left and right items, but no single linear function can segregate the red and blue items.</p>

<p>We need a non-linear function to seperate the groups, and neural networks can emulate a non-linear function that segregates them.</p>

<p>While this problem may seem relatively simple, it gave the initial neural networks quite a hard time. In fact, this is the problem that depleted much of the original enthusiasm for neural networks.</p>

<p>Neural networks can easily solve this problem, but they require an extra layer. Below I depict a network with an extra layer (a 2-layer network). To depict the network, I use a repository available on my <a href="https://github.com/dvatterott/visualise_neural_network">github</a>.</p>

<p>{% codeblock lang:python %}
from visualise_neural_network import NeuralNetwork</p>

<p>network = NeuralNetwork() #create neural network object
network.add_layer(2,[‘Input 1’,’Input 2’]) #input layer with names
network.add_layer(2,[‘Hidden 1’,’Hidden 2’]) #hidden layer with names
network.add_layer(1,[‘Output’]) #output layer with name
network.draw()
{% endcodeblock %}</p>

<p><img src="{{ root_url }}/images/neural_net/3_layer_net.png" /></p>

<p>Notice that this network now has 5 total neurons. The two units at the bottom are the <em>input layer</em>. The activity of input units is the value of the inputs (same as the inputs in my previous post). The two units in the middle are the <em>hidden layer</em>. The activity of hidden units are calculated in the same manner as the output units from my previous post. The unit at the top is the <em>output layer</em>. The activity of this unit is found in the same manner as in my previous post, but the activity of the hidden units replaces the input units.</p>

<p>Thus, when the neural network makes its guess, the only difference is we have to compute an extra layer’s activity.</p>

<p>The goal of this network is for the output unit to have an activity of 0 when presented with an item from the blue group (inputs are same) and to have an activity of 1 when presented with an item from the red group (inputs are different).</p>

<p>One additional aspect of neural networks that I haven’t discussed is each non-input unit can have a <em>bias</em>. You can think about bias as a propensity for the unit to become active or not to become active. For instance, a unit with a postitive bias is more likely to be active than a unit with no bias.</p>

<p>I will implement bias as an extra line feeding into each unit. The weight of this line is the bias, and the bias line is always active, meaning this bias is always present.</p>

<p>Below, I seed this 3-layer neural network with a random set of weights.</p>

<p>{% codeblock lang:python %}
np.random.seed(seed=10) #seed random number generator for reproducibility</p>

<p>Weights_2 = np.random.rand(1,3)-0.5<em>2 #connections between hidden and output
Weights_1 = np.random.rand(2,3)-0.5</em>2 #connections between input and hidden</p>

<p>Weight_Dict = {‘Weights_1’:Weights_1,’Weights_2’:Weights_2} #place weights in a dictionary</p>

<p>Train_Set = [[1.0,1.0],[0.0,0.0],[0.0,1.0],[1.0,0.0]] #train set</p>

<p>network = NeuralNetwork()
network.add_layer(2,[‘Input 1’,’Input 2’],
                  [[round(x,2) for x in Weight_Dict[‘Weights_1’][0][:2]],
                   [round(x,2) for x in Weight_Dict[‘Weights_1’][1][:2]]])
#add input layer with names and weights leaving the input neurons
network.add_layer(2,[round(Weight_Dict[‘Weights_1’][0][2],2),round(Weight_Dict[‘Weights_1’][1][2],2)],
                  [round(x,2) for x in Weight_Dict[‘Weights_2’][0][:2]])
#add hidden layer with names (each units’ bias) and weights leaving the hidden units
network.add_layer(1,[round(Weight_Dict[‘Weights_2’][0][2],2)])
#add output layer with name (the output unit’s bias)
network.draw()
{% endcodeblock %}</p>

<p><img src="{{ root_url }}/images/neural_net/3_layer_weights.png" /></p>

<p>Above we have out network. The depiction of <script type="math/tex">Weight_{Input_{1}\to.Hidden_{2}}</script> and <script type="math/tex">Weight_{Input_{2}\to.Hidden_{1}}</script> are confusing. -0.8 belongs to <script type="math/tex">Weight_{Input_{1}\to.Hidden_{2}}</script>. -0.5 belongs to <script type="math/tex">Weight_{Input_{2}\to.Hidden_{1}}</script>.</p>

<p>Lets go through one example of our network receiving an input and making a guess. Lets say the input is [0 1].
This means <script type="math/tex">Input_{1} = 0</script> and <script type="math/tex">Input_{2} = 1</script>. The correct answer in this case is 1.</p>

<p>First, we have to calculate <script type="math/tex">Hidden _{1}</script>’s input. Remember we can write input as</p>

<script type="math/tex; mode=display">net = \displaystyle\sum_{i=1}^{Inputs}Input_i * Weight_i</script>

<p>with the a bias we can rewrite it as</p>

<script type="math/tex; mode=display">net = Bias + \displaystyle\sum_{i=1}^{Inputs}Input_i * Weight_i</script>

<p>Specifically for <script type="math/tex">Hidden_{1}</script></p>

<script type="math/tex; mode=display">net_{Hidden_{1}} = -0.78 + -0.25*0 + -0.5*1 = -1.28</script>

<p>Remember the first term in the equation above is the bias term. Lets see what this looks like in code.</p>

<p>{% codeblock lang:python %}
Input = np.array([0,1])
net_Hidden = np.dot(np.append(Input,1.0),Weights_1.T) #append the bias input
print net_Hidden
{% endcodeblock %}</p>

<pre><code>[-1.27669634 -1.07035845]
</code></pre>

<p>Note that by using np.dot, I can calculate both hidden unit’s input in a single line of code.</p>

<p>Next, we have to find the activity of units in the hidden layer.</p>

<p>I will translate input into activity with a logistic function, as I did in the previous post.</p>

<script type="math/tex; mode=display">Logistic = \frac{1}{1+e^{-x}}</script>

<p>Lets see what this looks like in code.</p>

<p>{% codeblock lang:python %}
def logistic(x): #each neuron has a logistic activation function
    return 1.0/(1+np.exp(-x))</p>

<p>Hidden_Units = logistic(net_Hidden)
print Hidden_Units
{% endcodeblock %}</p>

<pre><code>[ 0.2181131   0.25533492]
</code></pre>

<p>So far so good, the logistic function has transformed the negative inputs into values near 0.</p>

<p>Now we have to compute the output unit’s acitivity.</p>

<script type="math/tex; mode=display">net_{Output} = Bias + Hidden_{1}*Weight_{Hidden_{1}\to.Output} + Hidden_{2}*Weight_{Hidden_{2}\to.Output}</script>

<p>plugging in the numbers</p>

<script type="math/tex; mode=display">net_{Output} = -0.37 + 0.22*-0.23 + 0.26*-0.98 = -0.67</script>

<p>Now the code for computing <script type="math/tex">net_{Output}</script> and the Output unit’s activity.</p>

<p>{% codeblock lang:python %}
net_Output = np.dot(np.append(Hidden_Units,1.0),Weights_2.T)
print ‘net_Output’
print net_Output
Output = logistic(net_Output)
print ‘Output’
print Output
{% endcodeblock %}</p>

<pre><code>net_Output
[-0.66626595]
Output
[ 0.33933346]
</code></pre>

<p>Okay, thats the network’s guess for one input…. no where near the correct answer (1). Let’s look at what the network predicts for the other input patterns. Below I create a feedfoward, 1-layer neural network and plot the neural nets’ guesses to the four input patterns.</p>

<p>{% codeblock lang:python %}
def layer_InputOutput(Inputs,Weights): #find a layers input and activity
    Inputs_with_bias = np.append(Inputs,1.0) #input 1 for each unit’s bias
    return logistic(np.dot(Inputs_with_bias,Weights.T))</p>

<p>def neural_net(Input,Weights_1,Weights_2,Training=False): #this function creates and runs the neural net</p>

<pre><code>target = 1 #set target value
if np.array(Input[0])==np.array([Input[1]]): target = 0 #change target value if needed

#forward pass
Hidden_Units = layer_InputOutput(Input,Weights_1) #find hidden unit activity
Output = layer_InputOutput(Hidden_Units,Weights_2) #find Output layer actiity

return {'output':Output,'target':target,'input':Input} #record trial output
</code></pre>

<p>Train_Set = [[1.0,1.0],[0.0,1.0],[1.0,0.0],[0.0,0.0]] #the four input patterns
tempdict = {‘output’:[],’target’:[],’input’:[]} #data dictionary
temp = [neural_net(Input,Weights_1,Weights_2) for Input in Train_Set] #get the data
[tempdict[key].append([temp[x][key] for x in range(len(temp))]) for key in tempdict] #combine all the output dictionaries</p>

<p>plotter = np.ones((2,2))*np.reshape(np.array(tempdict[‘output’]),(2,2))
plt.pcolor(plotter,vmin=0,vmax=1,cmap=plt.cm.bwr)
plt.colorbar(ticks=[0,0.25,0.5,0.75,1]);
plt.xlabel(‘Input 1’)
plt.ylabel(‘Input 2’)
plt.xticks([0.5,1.5], [‘0’,’1’])
plt.yticks([0.5,1.5], [‘0’,’1’]);
{% endcodeblock %}</p>

<p><img src="{{ root_url }}/images/neural_net/net_guess1_1.png" /></p>

<p>In the plot above, I have Input 1 on the x-axis and Input 2 on the y-axis. So if the Input is [0,0], the network produces the activity depicted in the lower left square. If the Input is [1,0], the network produces the activity depicted in the lower right square. If the network produces an output of 0, then the square will be blue. If the network produces an output of 1, then the square will be red. As you can see, the network produces all output between 0.25 and 0.5… no where near the correct answers.</p>

<p>So how do we update the weights in order to reduce the error between our guess and the correct answer?</p>

<p>First, we will do backpropogation between the output and hidden layers. This is exactly the same as backpropogation in the previous post.</p>

<p>In the previous post I described how our goal was to decrease error by changing the weights between units. This is the equation we used to describe changes in error with changes in the weights. The equation below expresses changes in error with changes to weights between the <script type="math/tex">Hidden_{1}</script> and the Output unit.</p>

<script type="math/tex; mode=display">\frac{\partial Error}{\partial Weight_{Hidden_{1}\to.Output}} = \frac{\partial Error}{\partial Output} * \frac{\partial Output}{\partial net_{Output}} * \frac{\partial net_{Output}}{\partial Weight_{Hidden_{1}\to.Output}}</script>

<script type="math/tex; mode=display">\begin{multline}
\frac{\partial Error}{\partial Weight_{Hidden_{1}\to.Output}} = -(target-Output) * Output(1-Output) * Hidden_{1} \\= -(1-0.34) * 0.34(1-0.34) * 0.22 = -0.03
\end{multline}</script>

<p>Now multiply this weight adjustment by the learning rate.</p>

<script type="math/tex; mode=display">\Delta Weight_{Input_{1}\to.Output} = \alpha * \frac{\partial Error}{\partial Weight_{Input_{1}\to.Output}}</script>

<p>Finally, we apply the weight adjustment to <script type="math/tex">Weight_{Hidden_{1}\to.Output}</script>.</p>

<script type="math/tex; mode=display">Weight_{Hidden_{1}\to.Output}^{\prime} = Weight_{Hidden_{1}\to.Output} - 0.5 * -0.03 = -0.23 - 0.5 * -0.03 = -0.21</script>

<p>Now lets do the same thing, but for both the weights and in the code.</p>

<p>{% codeblock lang:python %}
alpha = 0.5 #learning rate
target = 1 #target outpu</p>

<p>error = target - Output #amount of error
delta_out = np.atleast_2d(error<em>(Output</em>(1-Output))) #first two terms of error by weight derivative</p>

<p>Hidden_Units = np.append(Hidden_Units,1.0) #add an input of 1 for the bias
print Weights_2 + alpha*np.outer(delta_out,Hidden_Units) #apply weight change
{% endcodeblock %}</p>

<pre><code>[[-0.21252673 -0.96033892 -0.29229558]]
</code></pre>

<p>The hidden layer changes things when we do backpropogation. Above, we computed the new weights using the output unit’s error. Now, we want to find how adjusting a weight changes the error, but this weight connects an input to the hidden layer rather than connecting to the output layer. This means we have to propogate the error backwards to the hidden layer.</p>

<p>We will describe backpropogation for the line connecting <script type="math/tex">Input_{1}</script> and <script type="math/tex">Hidden_{1}</script> as</p>

<script type="math/tex; mode=display">\frac{\partial Error}{\partial Weight_{Input_{1}\to.Hidden_{1}}} = \frac{\partial Error}{\partial Hidden_{1}} * \frac{\partial Hidden_{1}}{\partial net_{Hidden_{1}}} * \frac{\partial net_{Hidden_{1}}}{\partial Weight_{Input_{1}\to.Hidden_{1}}}</script>

<p>Pretty similar. We just replaced Output with <script type="math/tex">Hidden_{1}</script>. The interpretation (starting with the final term and moving left) is that changing the <script type="math/tex">Weight_{Input_{1}\to.Hidden_{1}}</script> changes <script type="math/tex">Hidden_{1}</script>’s input. Changing <script type="math/tex">Hidden_{1}</script>’s input changes <script type="math/tex">Hidden_{1}</script>’s activity. Changing <script type="math/tex">Hidden_{1}</script>’s activity changes the error. This last assertion (the first term) is where things get complicated. Lets take a closer look at this first term</p>

<script type="math/tex; mode=display">\frac{\partial Error}{\partial Hidden_{1}} = \frac{\partial Error}{\partial net_{Output}} * \frac{\partial net_{Output}}{\partial Hidden_{1}}</script>

<p>Changing <script type="math/tex">Hidden_{1}</script>’s activity changes changes the input to the Output unit. Changing the output unit’s input changes the error. hmmmm still not quite there yet. Lets look at how changes to the output unit’s input changes the error.</p>

<script type="math/tex; mode=display">\frac{\partial Error}{\partial net_{Output}} = \frac{\partial Error}{\partial Output} * \frac{\partial Output}{\partial net_{Output}}</script>

<p>You can probably see where this is going. Changing the output unit’s input changes the output unit’s activity. Changing the output unit’s activity changes error. There we go.</p>

<p>Okay, this got a bit heavy, but here comes some good news. Compare the two terms of the equation above to the first two terms of our original backpropogation equation. They’re the same! Now lets look at <script type="math/tex">\frac{\partial net_{Output}}{\partial Hidden_{1}}</script> (the second term from the first equation after our new backpropogation equation).</p>

<script type="math/tex; mode=display">\frac{\partial net_{Output}}{\partial Hidden_{1}} = Weight_{Hidden_{1}\to Output}</script>

<p>Again, I am glossing over how to derive these partial derivatives. For a more complete explantion, I recommend <a href="http://www-psych.stanford.edu/~jlm/papers/PDP/Volume%201/Chap8_PDP86.pdf">Chapter 8 of Rumelhart and McClelland’s PDP book</a>. Nonetheless, this means we can take the output of our function <em>delta_output</em> multiplied by <script type="math/tex">Weight_{Hidden_{1}\to Output}</script> and we have the first term of our backpropogation equation! We want <script type="math/tex">Weight_{Hidden_{1}\to Output}</script> to be the weight used in the forward pass. Not the updated weight.</p>

<p>The second two terms from our backpropogation equation are the same as in our original backpropogation equation.</p>

<p><script type="math/tex">\frac{\partial Hidden_{1}}{\partial net_{Hidden_{1}}} = Hidden_{1}(1-Hidden_{1})</script> - this is specific to logistic activation functions.</p>

<p>and</p>

<script type="math/tex; mode=display">\frac{\partial net_{Hidden_{1}}}{\partial Weight_{1}} = Input_{1}</script>

<p>Lets try and write this out.</p>

<script type="math/tex; mode=display">\begin{multline}
\frac{\partial Error}{\partial Weight_{Input_{1}\to.Hidden_{1}}} = -(target-Output) * Output(1-Output) * Weight_{Hidden_{1}\to Output}\\* Hidden_{1}(1-Hidden_{1}) * Input_{1}
\end{multline}</script>

<p>It’s not short, but its doable. Let’s plug in the numbers.</p>

<script type="math/tex; mode=display">\frac{\partial Error}{\partial Weight_{Input_{1}\to.Hidden_{1}}} = -(1-0.34)*0.34(1-0.34)*-0.23*0.22(1-0.22)*0 = 0</script>

<p>Not too bad. Now lets see the code.</p>

<p>{% codeblock lang:python %}
delta_hidden = delta_out.dot(Weights_2)<em>(Hidden_Units</em>(1-Hidden_Units)) #find delta portion of weight update</p>

<p>delta_hidden = np.delete(delta_hidden,2) #remove the bias input
print Weights_1 + alpha*np.outer(delta_hidden,np.append(Input,1.0)) #append bias input and multiply input by delta portion
{% endcodeblock %}</p>

<pre><code>[[-0.25119612 -0.50149299 -0.77809147]
 [-0.80193714 -0.23946929 -0.84467792]]
</code></pre>

<p>Alright! Lets implement all of this into a single model and train the model on the XOR problem. Below I create a neural network that includes both a forward pass and an optional backpropogation pass.</p>

<p>{% codeblock lang:python %}
def neural_net(Input,Weights_1,Weights_2,Training=False): #this function creates and runs the neural net</p>

<pre><code>target = 1 #set target value
if np.array(Input[0])==np.array([Input[1]]): target = 0 #change target value if needed

#forward pass
Hidden_Units = layer_InputOutput(Input,Weights_1) #find hidden unit activity
Output = layer_InputOutput(Hidden_Units,Weights_2) #find Output layer actiity

if Training == True:
    alpha = 0.5 #learning rate

    Weights_2 = np.atleast_2d(Weights_2) #make sure this weight vector is 2d.

    error = target - Output #error
    delta_out = np.atleast_2d(error*(Output*(1-Output))) #delta between output and hidden

    Hidden_Units = np.append(Hidden_Units,1.0) #append an input for the bias
    delta_hidden = delta_out.dot(np.atleast_2d(Weights_2))*(Hidden_Units*(1-Hidden_Units)) #delta between hidden and input

    Weights_2 += alpha*np.outer(delta_out,Hidden_Units) #update weights

    delta_hidden = np.delete(delta_hidden,2) #remove bias activity
    Weights_1 += alpha*np.outer(delta_hidden,np.append(Input,1.0))  #update weights

if Training == False:
    return {'output':Output,'target':target,'input':Input} #record trial output
elif Training == True:
    return {'Weights_1':Weights_1,'Weights_2':Weights_2,'target':target,'output':Output,'error':error} {% endcodeblock %}
</code></pre>

<p>Okay, thats the network. Below, I train the network until its answers are very close to the correct answer.</p>

<p>{% codeblock lang:python %}
from random import choice
np.random.seed(seed=10) #seed random number generator for reproducibility</p>

<p>Weights_2 = np.random.rand(1,3)-0.5<em>2 #connections between hidden and output
Weights_1 = np.random.rand(2,3)-0.5</em>2 #connections between input and hidden</p>

<p>Weight_Dict = {‘Weights_1’:Weights_1,’Weights_2’:Weights_2}</p>

<p>Train_Set = [[1.0,1.0],[0.0,0.0],[0.0,1.0],[1.0,0.0]] #train set</p>

<p>Error = []
while True: #train the neural net
    Train_Dict = neural_net(choice(Train_Set),Weight_Dict[‘Weights_1’],Weight_Dict[‘Weights_2’],Training=True)</p>

<pre><code>Error.append(abs(Train_Dict['error']))
if len(Error) &gt; 6 and np.mean(Error[-10:]) &lt; 0.025: break #tell the code to stop iterating when recent mean error is small {% endcodeblock %}
</code></pre>

<p>Lets see how error changed across training</p>

<p>{% codeblock lang:python %}
Error_vec = np.array(Error)[:,0]
plt.plot(Error_vec)
plt.ylabel(‘Error’)
plt.xlabel(‘Iteration #’);
{% endcodeblock %}</p>

<p><img src="{{ root_url }}/images/neural_net/net_learn1_1.png" /></p>

<p>Really cool. The network start with volatile error - sometimes being nearly correct ans sometimes being completely incorrect. Then After about 5000 iterations, the network starts down the slow path of perfecting an answer scheme. Below, I create a plot depicting the networks’ activity for the different input patterns.</p>

<p>{% codeblock lang:python %}
Weights_1 = Weight_Dict[‘Weights_1’]
Weights_2 = Weight_Dict[‘Weights_2’]</p>

<p>Train_Set = [[1.0,1.0],[0.0,1.0],[1.0,0.0],[0.0,0.0]] #train set</p>

<p>tempdict = {‘output’:[],’target’:[],’input’:[]} #data dictionary
temp = [neural_net(Input,Weights_1,Weights_2) for Input in Train_Set] #get the data
[tempdict[key].append([temp[x][key] for x in range(len(temp))]) for key in tempdict] #combine all the output dictionaries</p>

<p>plotter = np.ones((2,2))*np.reshape(np.array(tempdict[‘output’]),(2,2))
plt.pcolor(plotter,vmin=0,vmax=1,cmap=plt.cm.bwr)
plt.colorbar(ticks=[0,0.25,0.5,0.75,1]);
plt.xlabel(‘Input 1’)
plt.ylabel(‘Input 2’)
plt.xticks([0.5,1.5], [‘0’,’1’])
plt.yticks([0.5,1.5], [‘0’,’1’]);
{% endcodeblock %}</p>

<p><img src="{{ root_url }}/images/neural_net/net_guess2_1.png" /></p>

<p>Again, the Input 1 value is on the x-axis and the Input 2 value is on the y-axis. As you can see, the network guesses 1 when the inputs are different and it guesses 0 when the inputs are the same. Perfect! Below I depict the network with these correct weights.</p>

<p>{% codeblock lang:python %}
Weight_Dict = {‘Weights_1’:Weights_1,’Weights_2’:Weights_2}</p>

<p>network = NeuralNetwork()
network.add_layer(2,[‘Input 1’,’Input 2’],
                  [[round(x,2) for x in Weight_Dict[‘Weights_1’][0][:2]],
                   [round(x,2) for x in Weight_Dict[‘Weights_1’][1][:2]]])
network.add_layer(2,[round(Weight_Dict[‘Weights_1’][0][2],2),round(Weight_Dict[‘Weights_1’][1][2],2)],
                  [round(x,2) for x in Weight_Dict[‘Weights_2’][:2][0]])
network.add_layer(1,[round(Weight_Dict[‘Weights_2’][0][2],2)])
network.draw()
{% endcodeblock %}</p>

<p><img src="{{ root_url }}/images/neural_net/3_layer_weights1.png" /></p>

<p>The network finds a pretty cool solution. Both hidden units are relatively active, but one hidden unit sends a strong postitive signal and the other sends a strong negative signal. The output unit has a negative bias, so if neither input is on, it will have an activity around 0. If both Input units are on, then the hidden unit that sends a postitive signal will be inhibited, and the output unit will have activity near 0. Otherwise, the hidden unit with a positive signal gives the output unit an acitivty near 1.</p>

<p>This is all well and good, but if you try to train this network with random weights you might find that it produces an incorrect set of weights sometimes. This is because the network runs into a <a href="https://en.wikipedia.org/wiki/Maxima_and_minima">local minima</a>. A local minima is an instance when any change in the weights would increase the error, so the network is left with a sub-optimal set of weights.</p>

<p>Below I hand-pick of set of weights that produce a local optima.</p>

<p>{% codeblock lang:python %}
Weights_2 = np.array([-4.5,5.3,-0.8]) #connections between hidden and output
Weights_1 = np.array([[-2.0,9.2,2.0],
                     [4.3,8.8,-0.1]])#connections between input and hidden</p>

<p>Weight_Dict = {‘Weights_1’:Weights_1,’Weights_2’:Weights_2}</p>

<p>network = NeuralNetwork()
network.add_layer(2,[‘Input 1’,’Input 2’],
                  [[round(x,2) for x in Weight_Dict[‘Weights_1’][0][:2]],
                   [round(x,2) for x in Weight_Dict[‘Weights_1’][1][:2]]])
network.add_layer(2,[round(Weight_Dict[‘Weights_1’][0][2],2),round(Weight_Dict[‘Weights_1’][1][2],2)],
                  [round(x,2) for x in Weight_Dict[‘Weights_2’][:2]])
network.add_layer(1,[round(Weight_Dict[‘Weights_2’][2],2)])
network.draw()
{% endcodeblock %}</p>

<p><img src="{{ root_url }}/images/neural_net/local_minimaWeights.png" /></p>

<p>Using these weights as the start of the training set, lets see what the network will do with training.</p>

<p>{% codeblock lang:python %}
Train_Set = [[1.0,1.0],[0.0,0.0],[0.0,1.0],[1.0,0.0]] #train set</p>

<p>Error = []
while True:
    Train_Dict = neural_net(choice(Train_Set),Weight_Dict[‘Weights_1’],Weight_Dict[‘Weights_2’],Training=True)</p>

<pre><code>Error.append(abs(Train_Dict['error']))
if len(Error) &gt; 6 and np.mean(Error[-10:]) &lt; 0.025: break
</code></pre>

<p>Error_vec = np.array(Error)[:]
plt.plot(Error_vec)
plt.ylabel(‘Error’)
plt.xlabel(‘Iteration #’);
{% endcodeblock %}</p>

<p><img src="{{ root_url }}/images/neural_net/net_learn2_1.png" /></p>

<p>As you can see the network never reduces error. Let’s see how the network answers to the different input patterns.</p>

<p>{% codeblock lang:python %}
Weights_1 = Weight_Dict[‘Weights_1’]
Weights_2 = Weight_Dict[‘Weights_2’]</p>

<p>Train_Set = [[1.0,1.0],[0.0,1.0],[1.0,0.0],[0.0,0.0]] #train set</p>

<p>tempdict = {‘output’:[],’target’:[],’input’:[]} #data dictionary
temp = [neural_net(Input,Weights_1,Weights_2) for Input in Train_Set] #get the data
[tempdict[key].append([temp[x][key] for x in range(len(temp))]) for key in tempdict] #combine all the output dictionaries</p>

<p>plotter = np.ones((2,2))*np.reshape(np.array(tempdict[‘output’]),(2,2))
plt.pcolor(plotter,vmin=0,vmax=1,cmap=plt.cm.bwr)
plt.colorbar(ticks=[0,0.25,0.5,0.75,1]);
plt.xlabel(‘Input 1’)
plt.ylabel(‘Input 2’)
plt.xticks([0.5,1.5], [‘0’,’1’])
plt.yticks([0.5,1.5], [‘0’,’1’]);
{% endcodeblock %}</p>

<p><img src="{{ root_url }}/images/neural_net/net_guess3_1.png" /></p>

<p>Looks like the network produces the correct answer in some cases but not others. The network is particularly confused when Inputs 2 is 0. Below I depict the weights after “training.” As you can see, they have not changed too much from where the weights started before training.</p>

<p>{% codeblock lang:python %}
Weights_1 = Weight_Dict[‘Weights_1’]
Weights_2 = Weight_Dict[‘Weights_2’]</p>

<p>Weight_Dict = {‘Weights_1’:Weights_1,’Weights_2’:Weights_2}</p>

<p>network = NeuralNetwork()
network.add_layer(2,[‘Input 1’,’Input 2’],
                  [[round(x,2) for x in Weight_Dict[‘Weights_1’][0][:2]],
                   [round(x,2) for x in Weight_Dict[‘Weights_1’][1][:2]]])
network.add_layer(2,[round(Weight_Dict[‘Weights_1’][0][2],2),round(Weight_Dict[‘Weights_1’][1][2],2)],
                  [round(x,2) for x in Weight_Dict[‘Weights_2’][:2]])
network.add_layer(1,[round(Weight_Dict[‘Weights_2’][2],2)])
network.draw()
{% endcodeblock %}</p>

<p><img src="{{ root_url }}/images/neural_net/local_minimaWeights1.png" /></p>

<p>This network was unable to push itself out of the local optima. While local optima are a problem, they’re are a couple things we can do to avoid them. First, we should always train a network multiple times with different random weights in order to test for local optima. If the network continually finds local optima, then we can increase the learning rate. By increasing the learning rate, the network can escape local optima in some cases. This should be done with care though as too big of a learning rate can also prevent finding the global minima.</p>

<p>Alright, that’s it. Obviously the neural network behind <a href="https://en.wikipedia.org/wiki/AlphaGo">alpha go</a> is much more complex than this one, but I would guess that while alpha go is much larger the basic computations underlying it are similar.</p>

<p>Hopefully these posts have given you an idea for how neural networks function and why they’re so cool!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[An Introduction to Neural Networks: Part 1]]></title>
    <link href="https://danvatterott.com/blog/2016/04/29/an-introduction-to-neural-networks-part-1/"/>
    <updated>2016-04-29T18:17:07-05:00</updated>
    <id>https://danvatterott.com/blog/2016/04/29/an-introduction-to-neural-networks-part-1</id>
    <content type="html"><![CDATA[<p>We use our most advanced technologies as metaphors for the brain: The industrial revolution inspired descriptions of the brain as mechanical. The telephone inspired descriptions of the brain as a telephone switchboard. The computer inspired descriptions of the brain as a computer. Recently, we have reached a point where our most advanced technologies - such as AI (e.g., <a href="https://en.wikipedia.org/wiki/AlphaGo">Alpha Go</a>), and our current understanding of the brain inform each other in an awesome synergy. Neural networks exemplify this synergy. Neural networks offer a relatively advanced description of the brain and are the software underlying some of our most advanced technology. As our understanding of the brain increases, neural networks become more sophisticated. As our understanding of neural networks increases, our understanding of the brain becomes more sophisticated.</p>

<p>With the recent success of neural networks, I thought it would be useful to write a few posts describing the basics of neural networks.</p>

<p>First, what are <a href="https://en.wikipedia.org/wiki/Artificial_neural_network">neural networks</a> - neural networks are a family of machine learning algorithms that can learn data’s underlying structure. Neural networks are composed of many <em>neurons</em> that perform simple computations. By performing many simple computations, neural networks can answer even the most complicated problems.</p>

<p>Lets get started.</p>

<p>As usual, I will post this code as a jupyter notebook on <a href="https://github.com/dvatterott/jupyter_notebooks">my github</a>.</p>

<p>{% codeblock lang:python %}
import numpy as np #import important libraries.
from matplotlib import pyplot as plt
import pandas as pd
%matplotlib inline</p>

<p>{% endcodeblock %}</p>

<p>When talking about neural networks, it’s nice to visualize the network with a figure. For drawing the neural networks, I forked a <a href="https://github.com/miloharper/visualise-neural-network">repository from miloharper</a> and made some changes so that this repository could be imported into python and so that I could label the network. <a href="https://github.com/dvatterott/visualise_neural_network">Here</a> is my forked repository.</p>

<p>{% codeblock lang:python %}
from visualise_neural_network import NeuralNetwork</p>

<p>network = NeuralNetwork() #create neural network object
network.add_layer(2,[‘Input A’,’Input B’],[‘Weight A’,’Weight B’]) #create the input layer which has two neurons.
#Each input neuron has a single line extending to the next layer up
network.add_layer(1,[‘Output’]) #create output layer - a single output neuron
network.draw() #draw the network
{% endcodeblock %}</p>

<p><img src="{{ root_url }}/images/neural_net/example1.png" /></p>

<p>Above is our neural network. It has two input neurons and a single output neuron. In this example, I’ll give the network an input of [0 1]. This means Input A will receive an input value of 0 and Input B will have an input value of 1.</p>

<p>The input is the input unit’s <em>activity.</em> This activity is sent to the Output unit, but the activity changes when traveling to the Output unit. The <em>weights</em> between the input and output units change the activity. A large positive weight between the input and output units causes the input unit to send a large positive (excitatory) signal. A large negative weight between the input and output units causes the input unit to send a large negative (inhibitory) signal. A weight near zero means the input unit does not influence the output unit.</p>

<p>In order to know the Output unit’s activity, we need to know its input. I will refer to the output unit’s input as <script type="math/tex">net_{Output}</script>. Here is how we can calculate <script type="math/tex">net_{Output}</script></p>

<script type="math/tex; mode=display">net_{Output} = Input_A * Weight_A + Input_B * Weight_B</script>

<p>a more general way of writing this is</p>

<script type="math/tex; mode=display">net = \displaystyle\sum_{i=1}^{Inputs}Input_i * Weight_i</script>

<p>Let’s pretend the inputs are [0 1] and the Weights are [0.25 0.5]. Here is the input to the output neuron -</p>

<script type="math/tex; mode=display">net_{Output} = 0 * 0.25 + 1 * 0.5</script>

<p>Thus, the input to the output neuron is 0.5. A quick way of programming this is through the function numpy.dot which finds the <a href="https://en.wikipedia.org/wiki/Dot_product">dot product</a> of two vectors (or matrices). This might sound a little scary, but in this case its just multiplying the items by each other and then summing everything up - like we did above.</p>

<p>{% codeblock lang:python %}
Inputs = np.array([0, 1])
Weights = np.array([0.25, 0.5])</p>

<p>net_Output = np.dot(Inputs,Weights)
print net_Output
{% endcodeblock %}</p>

<pre><code>0.5
</code></pre>

<p>All this is good, but we haven’t actually calculated the output unit’s activity we have only calculated its input. What makes neural networks able to solve complex problems is they include a non-linearity when translating the input into activity. In this case we will translate the input into activity by putting the input through a <a href="https://en.wikipedia.org/wiki/Logistic_function">logistic function</a>.</p>

<script type="math/tex; mode=display">Logistic = \frac{1}{1+e^{-x}}</script>

<p>{% codeblock lang:python %}
def logistic(x): #each neuron has a logistic activation function
    return 1.0/(1+np.exp(-x))
{% endcodeblock %}</p>

<p>Lets take a look at a logistic function.</p>

<p>{% codeblock lang:python %}
x = np.arange(-5,5,0.1) #create vector of numbers between -5 and 5
plt.plot(x,logistic(x))
plt.ylabel(‘Activation’)
plt.xlabel(‘Input’);
{% endcodeblock %}</p>

<p><img src="{{ root_url }}/images/neural_net/logistic1.png" /></p>

<p>As you can see above, the logistic used here transforms negative values into values near 0 and positive values into values near 1. Thus, when a unit receives a negative input it has activity near zero and when a unit receives a postitive input it has activity near 1. The most important aspect of this activation function is that its non-linear - it’s not a straight line.</p>

<p>Now lets see the activity of our output neuron. Remember, the net input is 0.5</p>

<p>{% codeblock lang:python %}
Output_neuron = logistic(net_Output)
print Output_neuron
plt.plot(x,logistic(x));
plt.ylabel(‘Activation’)
plt.xlabel(‘Input’)
plt.plot(net_Output,Output_neuron,’ro’);
{% endcodeblock %}</p>

<pre><code>0.622459331202
</code></pre>

<p><img src="{{ root_url }}/images/neural_net/logistic2.png" /></p>

<p>The activity of our output neuron is depicted as the red dot.</p>

<p>So far I’ve described how to find a unit’s activity, but I haven’t described how to find the weights of connections between units. In the example above, I chose the weights to be 0.25 and 0.5, but I can’t arbitrarily decide weights unless I already know the solution to the problem. If I want the network to find a solution for me, I need the network to find the weights itself.</p>

<p>In order to find the weights of connections between neurons, I will use an algorithm called <a href="https://en.wikipedia.org/wiki/Backpropagation">backpropogation</a>. In backpropogation, we have the neural network guess the answer to a problem and adjust the weights so that this guess gets closer and closer to the correct answer. Backpropogation is the method by which we reduce the distance between guesses and the correct answer. After many iterations of guesses by the neural network and weight adjustments through backpropogation, the network can learn an answer to a problem.</p>

<p>Lets say we want our neural network to give an answer of 0 when the left input unit is active and an answer of 1 when the right unit is active. In this case the inputs I will use are [1,0] and [0,1]. The corresponding correct answers will be [0] and [1].</p>

<p>Lets see how close our network is to the correct answer. I am using the weights from above ([0.25, 0.5]).</p>

<p>{% codeblock lang:python %}
Inputs = [[1,0],[0,1]]
Answers = [0,1,]</p>

<p>Guesses = [logistic(np.dot(x,Weights)) for x in Inputs] #loop through inputs and find logistic(sum(input*weights))
plt.plot(Guesses,’bo’)
plt.plot(Answers,’ro’)
plt.axis([-0.5,1.5,-0.5,1.5])
plt.ylabel(‘Activation’)
plt.xlabel(‘Input #’)
plt.legend([‘Guesses’,’Answers’]);
print Guesses
{% endcodeblock %}</p>

<pre><code>[0.56217650088579807, 0.62245933120185459]
</code></pre>

<p><img src="{{ root_url }}/images/neural_net/net_guess1.png" /></p>

<p>The guesses are in blue and the answers are in red. As you can tell, the guesses and the answers look almost nothing alike. Our network likes to guess around 0.6 while the correct answer is 0 in the first example and 1 in the second.</p>

<p>Lets look at how backpropogation reduces the distance between our guesses and the correct answers.</p>

<p>First, we want to know how the amount of error changes with an adjustment to a given weight. We can write this as</p>

<script type="math/tex; mode=display">\partial Error \over \partial Weight_{Input_{1}\to.Output}</script>

<p>This change in error with changes in the weights has a number of different sub components.</p>

<ul>
  <li>Changes in error with changes in the output unit’s activity: <script type="math/tex">\partial Error \over \partial Output</script></li>
  <li>Changes in the output unit’s activity with changes in this unit’s input: <script type="math/tex">\partial Output \over \partial net_{Output}</script></li>
  <li>Changes in the output unit’s input with changes in the weight: <script type="math/tex">\partial net_{Output} \over \partial Weight_{Input_{1}\to.Output}</script></li>
</ul>

<p>Through the <a href="https://en.wikipedia.org/wiki/Chain_rule">chain rule</a> we know</p>

<script type="math/tex; mode=display">\frac{\partial Error}{\partial Weight_{Input_{1}\to.Output}} = \frac{\partial Error}{\partial Output} * \frac{\partial Output}{\partial net_{Output}} * \frac{\partial net_{Output}}{\partial Weight_{Input_{1}\to.Output}}</script>

<p>This might look scary, but with a little thought it should make sense: (starting with the final term and moving left) When we change the weight of a connection to a unit, we change the input to that unit. When we change the input to a unit, we change its activity (written Output above). When we change a units activity, we change the amount of error.</p>

<p>Let’s break this down using our example. During this portion, I am going to gloss over some details about how exactly to derive the partial derivatives. <a href="https://en.wikipedia.org/wiki/Delta_rule">Wikipedia has a more complete derivation</a>.</p>

<p>In the first example, the input is [1,0] and the correct answer is [0]. Our network’s guess in this example was about 0.56.</p>

<script type="math/tex; mode=display">\frac{\partial Error}{\partial Output} = -(target-Output) = -(0-0.56)</script>

<script type="math/tex; mode=display">\frac{\partial Output}{\partial net_{Output}} = Output(1-Output) = 0.56*(1-0.56)</script>

<p>Please note that this is specific to our example with a logistic activation function</p>

<script type="math/tex; mode=display">\frac{\partial net_{Output}}{\partial Weight_{Input_{1}\to.Output}} = Input_{1} = 1</script>

<p>To summarize:</p>

<script type="math/tex; mode=display">\begin{multline}
\frac{\partial Error}{\partial Weight_{Input_{1}\to.Output}} = -(target-Output) * Output(1-Output) * Input_{1} \\
= -(0-0.56) * 0.56(1-0.56) * 1 = 0.14
\end{multline}</script>

<p>This is the direction we want to move in, but taking large steps in this direction can prevent us from finding the optimal weights. For this reason, we reduce our step size. We will reduce our step size with a parameter called the <em>learning rate</em> (<script type="math/tex">\alpha</script>). <script type="math/tex">\alpha</script> is bound between 0 and 1.</p>

<p>Here is how we can write our change in weights</p>

<script type="math/tex; mode=display">\Delta Weight_{Input_{1}\to.Output} = \alpha * \frac{\partial Error}{\partial Weight_{Input_{1}\to.Output}}</script>

<p>This is known as the <a href="https://en.wikipedia.org/wiki/Delta_rule">delta rule</a>.</p>

<p>We will set <script type="math/tex">\alpha</script> to be 0.5. Here is how we will calculate the new <script type="math/tex">Weight_{Input_{1}\to.Output}</script>.</p>

<script type="math/tex; mode=display">Weight_{Input_{1}\to.Output}^{\prime} = Weight_{Input_{1}\to.Output} - 0.5 * 0.14 = 0.25 - 0.5 * 0.14 = 0.18</script>

<p>Thus, <script type="math/tex">Weight_{Input_{1}\to.Output}</script> is shrinking which will move the output towards 0. Below I write the code to implement our backpropogation.</p>

<p>{% codeblock lang:python %}
alpha = 0.5</p>

<p>def delta_Output(target,Output):
    return -(target-Output)<em>Output</em>(1-Output) #find the amount of error and derivative of activation function</p>

<p>def update_weights(alpha,delta,unit_input):
    return alpha*np.outer(delta,unit_input) #multiply delta output by all the inputs and then multiply these by the learning rate
{% endcodeblock %}</p>

<p>Above I use the <a href="https://en.wikipedia.org/wiki/Outer_product">outer product</a> of our delta function and the input in order to spread the weight changes to all lines connecting to the output unit.</p>

<p>Okay, hopefully you made it through that. I promise thats as bad as it gets. Now that we’ve gotten through the nasty stuff, lets use backpropogation to find an answer to our problem.</p>

<p>{% codeblock lang:python %}
def network_guess(Input,Weights):
    return logistic(np.dot(Input,Weights.T)) #input by weights then through a logistic</p>

<p>def back_prop(Input,Output,target,Weights):
    delta = delta_Output(target,Output) #find delta portion
    delta_weight = update_weights(alpha,delta,Input) #find amount to update weights
    Weights = np.atleast_2d(Weights) #convert weights to array
    Weights += -delta_weight #update weights
    return Weights</p>

<p>from random import choice, seed
seed(1) #seed random number generator so that these results can be replicated</p>

<p>Weights = np.array([0.25, 0.5])</p>

<p>Error = []
while True:</p>

<pre><code>Trial_Type = choice([0,1]) #generate random number to choose between the two inputs

Input = np.atleast_2d(Inputs[Trial_Type]) #choose input and convert to array
Answer = Answers[Trial_Type] #get the correct answer

Output = network_guess(Input,Weights) #compute the networks guess
Weights = back_prop(Input,Output,Answer,Weights) #change the weights based on the error

Error.append(abs(Output-Answer)) #record error

if len(Error) &gt; 6 and np.mean(Error[-5:]) &lt; 0.05: break #tell the code to stop iterating when mean error is &lt; 0.05 in the last 5 guesses {% endcodeblock %}
</code></pre>

<p>It seems our code has found an answer, so lets see how the amount of error changed as the code progressed.</p>

<p>{% codeblock lang:python %}
Error_vec = np.array(Error)[:,0]
plt.plot(Error_vec)
plt.ylabel(‘Error’)
plt.xlabel(‘Iteration #’);</p>

<p>{% endcodeblock %}</p>

<p><img src="{{ root_url }}/images/neural_net/net_learn1.png" /></p>

<p>It looks like the while loop excecuted about 1000 iterations before converging. As you can see the error decreases. Quickly at first then slowly as the weights zone in on the correct answer. lets see how our guesses compare to the correct answers.</p>

<p>{% codeblock lang:python %}
Inputs = [[1,0],[0,1]]
Answers = [0,1,]</p>

<p>Guesses = [logistic(np.dot(x,Weights.T)) for x in Inputs] #loop through inputs and find logistic(sum(input*weights))
plt.plot(Guesses,’bo’)
plt.plot(Answers,’ro’)
plt.axis([-0.5,1.5,-0.5,1.5])
plt.ylabel(‘Activation’)
plt.xlabel(‘Input #’)
plt.legend([‘Guesses’,’Answers’]);
print Guesses
{% endcodeblock %}</p>

<pre><code>[array([ 0.05420561]), array([ 0.95020512])]
</code></pre>

<p><img src="{{ root_url }}/images/neural_net/net_guess2.png" /></p>

<p>Not bad! Our guesses are much closer to the correct answers than before we started running the backpropogation procedure! Now, you might say, “HEY! But you haven’t reached the <em>correct</em> answers.” That’s true, but note that acheiving the values of 0 and 1 with a logistic function are only possible at -<script type="math/tex">\infty</script> and <script type="math/tex">\infty</script>, respectively. Because of this, we treat 0.05 as 0 and 0.95 as 1.</p>

<p>Okay, all this is great, but that was a really simple problem, and I said that neural networks could solve interesting problems!</p>

<p>Well… this post is already longer than I anticipated. I will follow-up this post with another post explaining how we can expand neural networks to solve more interesting problems.</p>
]]></content>
  </entry>
  
</feed>
